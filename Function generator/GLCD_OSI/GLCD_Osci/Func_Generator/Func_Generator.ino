
#include <avr/pgmspace.h>


static const uint8_t  sineTable[] PROGMEM =

{
0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,
0x98,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,
0xb0,0xb3,0xb6,0xb9,0xbc,0xbf,0xc1,0xc4,
0xc7,0xc9,0xcc,0xce,0xd1,0xd3,0xd5,0xd8,
0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,
0xea,0xec,0xed,0xef,0xf0,0xf2,0xf3,0xf5,
0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfc,
0xfd,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfe,
0xfd,0xfc,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,
0xf6,0xf5,0xf3,0xf2,0xf0,0xef,0xed,0xec,
0xea,0xe8,0xe6,0xe4,0xe2,0xe0,0xde,0xdc,
0xda,0xd8,0xd5,0xd3,0xd1,0xce,0xcc,0xc9,
0xc7,0xc4,0xc1,0xbf,0xbc,0xb9,0xb6,0xb3,
0xb0,0xae,0xab,0xa8,0xa5,0xa2,0x9f,0x9c,
0x98,0x95,0x92,0x8f,0x8c,0x89,0x86,0x83,
0x80,0x7c,0x79,0x76,0x73,0x70,0x6d,0x6a,
0x67,0x63,0x60,0x5d,0x5a,0x57,0x54,0x51,
0x4f,0x4c,0x49,0x46,0x43,0x40,0x3e,0x3b,
0x38,0x36,0x33,0x31,0x2e,0x2c,0x2a,0x27,
0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,
0x15,0x13,0x12,0x10,0x0f,0x0d,0x0c,0x0a,
0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,
0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,
0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08,
0x09,0x0a,0x0c,0x0d,0x0f,0x10,0x12,0x13,
0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
0x25,0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,
0x38,0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,
0x4f,0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,
0x67,0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c
};
int pwmPin = 9;
uint16_t phaseAccumulator = 0;
// 16 bit delta
uint16_t phaseIncrement = 0;
// DDS resolution

const uint32_t resolution =  68719;
uint8_t index = 0;
uint16_t frequency = 440;
// Updates the OCR1A value and the accumulator.
// Computes the next sample to be sent to the PWM.

#include <openGLCD.h>
static const uint8_t  ramp[] PROGMEM= {0x2,0x4,0x6,0x8,0xa,0xc,0xe,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,0x20,0x22,0x24,0x26,0x28,
0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,
0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,
0x7a,0x7c,0x7e,0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,0xa0,
0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,0xc0,0xc2,0xc4,0xc6,0xc8,
0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,
0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,0xff,0xfe,0xfc,0xfa,0xf8,0xf6,0xf4,0xf2,0xf0,0xee,0xec,0xea,0xe8,
0xe6,0xe4,0xe2,0xe0,0xde,0xdc,0xda,0xd8,0xd6,0xd4,0xd2,0xd0,0xce,0xcc,0xca,0xc8,0xc6,0xc4,0xc2,0xc0,
0xbe,0xbc,0xba,0xb8,0xb6,0xb4,0xb2,0xb0,0xae,0xac,0xaa,0xa8,0xa6,0xa4,0xa2,0xa0,0x9e,0x9c,0x9a,0x98,
0x96,0x94,0x92,0x90,0x8e,0x8c,0x8a,0x88,0x86,0x84,0x82,0x80,0x7e,0x7c,0x7a,0x78,0x76,0x74,0x72,0x70,
0x6e,0x6c,0x6a,0x68,0x66,0x64,0x62,0x60,0x5e,0x5c,0x5a,0x58,0x56,0x54,0x52,0x50,0x4e,0x4c,0x4a,0x48,
0x46,0x44,0x42,0x40,0x3e,0x3c,0x3a,0x38,0x36,0x34,0x32,0x30,0x2e,0x2c,0x2a,0x28,0x26,0x24,0x22,0x20,
0x1e,0x1c,0x1a,0x18,0x16,0x14,0x12,0x10,0xe,0xc,0xa,0x8,0x6,0x4,0x2,0x0};

static const uint8_t  squarex[] PROGMEM= {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

int val=3;

#include "fonts/allFonts.h"
long time_div;
int sig_v[113];
void setup() {
  // Initialize the GLCD 
 
  GLCD.Init();   // initialise the library, non inverted writes pixels onto a clear screen
  GLCD.ClearScreen();
  GLCD.SelectFont(System5x7, BLACK);
  GLCD.CursorToXY( 0,2);
  GLCD.print("5V"); 
  GLCD.CursorToXY(0,46);
  GLCD.print("0V");
  GLCD.DrawVLine(14, 0, 54, BLACK);
  
 // GLCD.DrawHLine(0, 54, 127, BLACK);
  GLCD.DrawHLine(11, 53, 3, BLACK);
  GLCD.DrawHLine(11, 26, 3, BLACK);
  GLCD.DrawHLine(11, 0, 3, BLACK);
  GLCD.CursorToXY(0,57);
  GLCD.print("Freq:");
  
  GLCD.DrawVLine(78, 55, 8, BLACK);
  GLCD.CursorToXY(82,57);
  GLCD.print("A:");
 // Serial.begin(9600);

time_div = (1/frequency)*1000000;

initPWM();


setFrequency( frequency );

sei();
  }

void loop() {
 // int sig = analogRead(0);
  int test_up,test_down; 

  int min_amp=53, max_amp=0;
   
  for(int i=0;i<113;i++)
{
//  sine= ((sin(i*(3.14/180))*127)+127);
//  delayMicroseconds(900);
 //sig= analogRead(0);
 //delayMicroseconds(10);
 sig_v[i] = map(analogRead(A5), 0, 1023, 1, 51);

 delayMicroseconds(time_div); 
}
//GLCD.ClearScreen()   ;


GLCD.FillRect( 15, 0, 112, 53, WHITE);
//GLCD.DrawVLine(70, 0, 53, BLACK);
//GLCD.DrawHLine(14, 26, 113, BLACK);
  for(int i=0;i<113;i++)
  {
  test_up=(53-sig_v[i+1]) - (53-sig_v[i]);
  test_down=(53-sig_v[i]) - (53-sig_v[i+1]);
  if(test_up>0 && i!=112)
  {
    GLCD.DrawLine( i+15, 53-sig_v[i], i+15, 53-sig_v[i+1], BLACK);
  }
  else if(test_down>0 && i!=112)
  GLCD.DrawLine( i+15, 53-sig_v[i+1], i+15, 53-sig_v[i], BLACK);
  else
   GLCD.SetDot(i+15, 53-sig_v[i], BLACK);
  //Serial.println(sig_v[i]);
  min_amp=min(min_amp,sig_v[i]);
  max_amp=max(max_amp,sig_v[i]);
  
  }
  //GLCD.FillRect( 64, 57, 63, 7, WHITE);
  GLCD.CursorToXY(40,57);
  GLCD.print(frequency);
  GLCD.print("Hz");
  GLCD.CursorToXY(94,57);
  GLCD.print((max_amp-min_amp)/10.6);
  GLCD.print("V");
  }
  
  
 
 ISR(TIMER1_OVF_vect)
{

static uint8_t osc = 0;
// Send oscillator output to PWM
OCR1A = osc;

// Update accumulator

phaseAccumulator += phaseIncrement;
index = phaseAccumulator >> 8;

switch(val){
// Read oscillator value for next interrupt
 case 1: osc = pgm_read_byte( &sineTable[index] ); break;
 case 2: osc = pgm_read_byte( &ramp[index] );break;
 case 3: osc = pgm_read_byte( &squarex[index] );break;
}
}
void initPWM(void)

{

pinMode(pwmPin, OUTPUT);
 

// 8-bit Fast PWM - non inverted PWM
TCCR1A= _BV(COM1A1) | _BV(WGM10) ;
  
 
// Start timer without prescaler
TCCR1B = _BV(CS10) | _BV(WGM12);
 
// Enable overflow interrupt for OCR1A
TIMSK1 = _BV(TOIE1);

}

// scale factor of the resolution.

void setFrequency( uint32_t frequency )
{

uint64_t phaseIncr64 =  resolution * frequency;
phaseIncrement = phaseIncr64 >> 16;

}
